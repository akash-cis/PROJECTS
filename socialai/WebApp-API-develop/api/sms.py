# Download the helper library from https://www.twilio.com/docs/python/install
from datetime import datetime, timedelta
from phonenumbers.util import prnt

from twilio.base.exceptions import TwilioRestException
from twilio.rest import Client
from sqlalchemy import func

from api.utils.fcm_util import FCMInit
from api.utils.trigger_nudge_event import TriggerNudgeEvent
from api import db
from api import utils
from api.models import CrmIntegration, FCMDevice, Leads, LeadPhones, Message, MessageLog, CampaignLeadSummary, \
                            Appointment, User, Company, Campaign, VinSolutionsUser, CampaignTypes, CampaignManageType, Notification
from config import TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, CALLBACK_URL, SITE_TITLE
from api.utils import util, encrypt_decrypt, socketio_trigger

import uuid, os, pytz

APP_URL = os.getenv('CORS_ORIGIN', 'http://localhost:8000')
fcm_init = FCMInit()
trigger_nudge_event = TriggerNudgeEvent()

account_sid = TWILIO_ACCOUNT_SID
auth_token = TWILIO_AUTH_TOKEN
client = Client(account_sid, auth_token)

socketio_obj = socketio_trigger.SocketIOTrigger()


def send_sms(from_number, to_number, message_body):
    """Sends SMS message using Twilio.

    This uses the Twilio Python Helper Library to send SMS to a give phone number. The `from_number` is typically a
    number bought from Twilio.

    The status callback passed Twilio is important as that is where the webhook call will be sent about the status of
    message (sent, delivered, etc.)

    Args:
        from_number: A string representing the phone number to send the message from.
        to_number: A string representing the phone number to send the message to.
        message_body: A string representing the message to be sent.

    Returns:
        string: A string representing the ID of the message generated by Twilio.
    """
    try:
        message = client.messages \
                        .create(
                            body=message_body,
                            # Instead of from_ we create a messaging service with a pool of numbers
                            # and send using the message service.
                            # messaging_service_sid='MG9752274e9e519418a7406176694466fa',
                            from_=from_number,
                            status_callback=f'{CALLBACK_URL}/message-status',
                            to=to_number
                        )
        return message.sid
    except TwilioRestException as e:
        print(e)
        return None


def receive_sms(from_number, to_number, message_body, message_sid):
    """Processes the received SMS.

    This function processes the received SMS and performs various actions based on context.

    Args:
        from_number: A string representing the phone number message was sent from.
        to_number: A string representing the phone number the message was sent to.
        message_body: A string representing the message that was received.
        message_sid: A string representing the ID of the message generated by Twilio.
    """
    print('in receive_sms')
    print(f'from_number = {from_number}, to_number = {to_number}, message_sid = {message_sid}, '
          f'message_body = {message_body}')
    # Get the company based on the `to_number`.
    companies_by_phone = db.session.query(Company).join(User) \
        .filter(User.company_id == Company.id, User.phone == to_number) \
        .all()
    if not companies_by_phone:
        raise Exception(f"Not found user records for that number")

    if len(companies_by_phone) > 1:
        raise Exception(f"Found multiple companies with the same phone number. Each SMAI phone bot should have a "
                        f"different phone number per company.")

    lead_company = companies_by_phone[0]
    # Get leads that match the number this message was received from, and the company
    lead = db.session.query(Leads).join(LeadPhones)\
        .filter(LeadPhones.phone == from_number, Leads.is_deleted == False, Leads.company_id == lead_company.id)\
        .all()

    # Words that drive specific actions to be taken based on the received message
    START_WORDS = ('START', 'YES', 'UNSTOP')
    STOP_WORDS = ('STOP', 'STOPALL', 'UNSUBSCRIBE', 'CANCEL', 'END', 'QUIT')
    # Messages that drive specific actions to be taken on appointments
    # C for Confirm, R for Reschedule and D for Decline
    APPOINTMENT_ACTIONS = ["C", "R", "D"]

    received_date = datetime.utcnow()
    for row in lead:
        print(f'processing lead {row.id}')
        if message_body.upper() in STOP_WORDS:
            row.text_consent_status = 'DECLINED'
            row.text_consent = False
            row.text_consent_date = datetime.utcnow()
            db.session.add(row)
            db.session.commit()
        if message_body.upper() in START_WORDS:
            row.text_consent_status = 'ACCEPTED'
            row.text_consent = True
            row.text_consent_date = datetime.utcnow()
            db.session.add(row)
            db.session.commit()

        is_general_reply = True
        user = None
        to_phone = None
        
        # Process appointment actions
        if message_body.upper() in APPOINTMENT_ACTIONS:
            is_general_reply = False
            appointments = db.session.query(Appointment).filter(
                Appointment.lead_id == row.id, Appointment.end_datetime > datetime.utcnow(),
                Appointment.appointment_status != "CANCELLED"
            ).all()
            if len(appointments) > 1:
                raise Exception(f"Error: More than one active appointment found for the lead {row.id}")
            if appointments:
                appointment = appointments[0]
            else:
                # There are no appointments found for this lead, so move on to the next lead
                # There is no need to raise an error, as there could be multiple leads matching the phone number the
                # message was received from. For e.g., a person could be a lead for multiple companies, in which case
                # there will be multiple lead records with the same phone number.
                print(f"Error: No appointment record found for lead {row.id}")
                continue

            user = db.session.query(User).filter(User.id == appointment.user_id).first()
            print(f"Appointment user = {user.id}, phone = {user.phone}")
            
            to_phone = appointment.lead_phone
            appt_notif_phone = None
            user_phone = None
            local_start_date = None
            local_start_time = None
            if user and user.phone:
                # Get appointment notification phone number
                appt_notif_phone, _ = util.get_from_number(db.session, appointment.company_id, 'APPOINTMENT')
                if not appt_notif_phone:
                    raise Exception(
                        f"Error: Unable to find System User/Phone for the company {appointment.company_id}")
                # Phone number of the user to which the notification will be sent
                user_phone = user.phone
                print(f"appt_notif_phone (twilio) = {appt_notif_phone}, user_phone (user) = {user_phone}")
                # Get the local start date and time of the appointment
                timezone = pytz.timezone(appointment.timezone)
                utc_start_datetime = appointment.start_datetime.replace(tzinfo=pytz.UTC)
                local_start_datetime = utc_start_datetime.astimezone(timezone)
                local_start_date = local_start_datetime.strftime("%A, %B %d, %Y")
                local_start_time = local_start_datetime.strftime("%I:%M %p")

            lead_activity = None
            if message_body.upper() == "C":
                lead_activity = 'CONFIRMED_APPOINTMENT'
                if appt_notif_phone and user_phone:
                    conf_message_sid = send_sms(
                        from_number=appt_notif_phone, to_number=user_phone,
                        message_body=(
                            f"Appointment with {row.full_name} is confirmed for {local_start_date} "
                            f"at {local_start_time} {local_start_datetime.tzname()}"
                        )
                    )
                    print(f"conf_message_sid = {conf_message_sid}")
                appointment.is_confirmed = True
                db.session.add(appointment)
                db.session.commit()
                
                content = f"""Your appointment at {user.company.name} on {local_start_date} at {local_start_time} {local_start_datetime.tzname()} has been confirmed. 
Reply R to Reschedule, D to Decline, STOP to opt out.
Location: {util.get_formatted_address(user.company)}"""
                message_sid = send_sms(from_number=appt_notif_phone, to_number=appointment.lead_phone, message_body=content)
                if message_sid:
                    message = Message(
                        system_user_id=None, lead_id=appointment.lead_id, user_id=user.id, direction="TO_LEAD",
                        date_sent=datetime.utcnow(), content=content, message_sid=message_sid
                    )
                    db.session.add(message)
                    db.session.commit()

            elif message_body.upper() == "R":
                if appt_notif_phone and user_phone:
                    send_sms(
                        from_number=appt_notif_phone, to_number=user_phone,
                        message_body=(
                            f"{row.full_name} would like to reschedule their current appointment on {local_start_date} "
                            f"at {local_start_time} {local_start_datetime.tzname()} to some other time"
                        )
                    )
                
#                 content = f"""Your appointment at {user.company.name} to {local_start_date} at {local_start_time} has been rescheduled. 
# Reply C to Confirm, R to Reschedule, D to Decline, STOP to opt out.
# Location: {util.get_formatted_address(user.company)}"""
                token_text = f'{str(appointment.id)}|{datetime.utcnow() + timedelta(days=30)}'
                encrypted_appointment_id = encrypt_decrypt.Crypt().encrypt_message(token_text)
                calender_url = f'http://cal-stage.socialminingai.com/acal/{encrypted_appointment_id}'
                content = f"""No problem, please click the link below and select a different date and time for your appointment.
                
{util.make_shorten(calender_url)}"""

                message_sid = send_sms(from_number=appt_notif_phone, to_number=appointment.lead_phone, message_body=content)
                if message_sid:
                    message = Message(
                        system_user_id=None, lead_id=appointment.lead_id, user_id=user.id, direction="TO_LEAD",
                        date_sent=datetime.utcnow(), content=content, message_sid=message_sid
                    )
                    db.session.add(message)
                    db.session.commit()

            elif message_body.upper() == "D":
                lead_activity = 'CANCELED_APPOINTMENT'
                if appt_notif_phone and user_phone:
                    canc_message_sid = send_sms(
                        from_number=appt_notif_phone, to_number=user_phone,
                        message_body=(
                            f"Appointment with {row.full_name} on {local_start_date} at {local_start_time} {local_start_datetime.tzname()} has been "
                            f"cancelled by {row.full_name}"
                        )
                    )
                    print(f"canc_message_sid = {canc_message_sid}")
                appointment.sequence += 1
                appointment.appointment_status = "CANCELLED"
                db.session.add(appointment)
                db.session.commit()

                # content = f"""Your appointment at {user.company.name} on {local_start_date} at {local_start_time} has been cancelled."""
                token_text = f'{str(appointment.id)}|{datetime.utcnow() + timedelta(days=30)}'
                encrypted_appointment_id = encrypt_decrypt.Crypt().encrypt_message(token_text)
                calender_url = f'http://cal-stage.socialminingai.com/acal/{encrypted_appointment_id}'
                content = f"""Sorry the appointment cannot work for you. If you would like to reschedule in the next 4 hours, click the link below to set a new date and time.
                
{util.make_shorten(calender_url)}"""
                message_sid = send_sms(from_number=appt_notif_phone, to_number=appointment.lead_phone, message_body=content)
                if message_sid:
                    message = Message(
                        system_user_id=None, lead_id=appointment.lead_id, user_id=user.id, direction="TO_LEAD",
                        date_sent=datetime.utcnow(), content=content, message_sid=message_sid
                    )
                    db.session.add(message)
                    db.session.commit()

            if lead_activity:
                util.update_lead_status(row, lead_activity=lead_activity)
        
        # Get the most recent message sent to the lead from an automated campaign
        last_message = db.session.query(Message) \
            .filter(Message.lead_id == row.id, Message.date_sent != None, Message.user_id == None) \
            .order_by(Message.id.desc()) \
            .first()
        if last_message:
            campaign_id = last_message.campaign_id
        else:
            # Get the most recent message sent to the lead manually
            last_message = db.session.query(Message) \
                .filter(Message.lead_id == row.id, Message.date_sent != None, Message.user_id != None) \
                .order_by(Message.id.desc()).first()
            default_campaign = db.session.query(Campaign) \
                .join(CampaignTypes) \
                .filter(CampaignTypes.type == CampaignManageType.DEFAULT, Campaign.company_id == row.company_id) \
                .first()
            campaign_id = default_campaign.id if default_campaign else None

        # Save the received message
        message = Message(
            lead_id=row.id, direction="FROM_LEAD", date_received=received_date, content=message_body,
            message_sid=message_sid, message_status="received", campaign_id=campaign_id, is_read=False)
        db.session.add(message)
        db.session.commit()
        message_log = MessageLog(message_id=message.id, from_phone=from_number, to_phone=to_number)
        db.session.add(message_log)
        db.session.commit()

        row.unread_count += 1
        db.session.add(row)
        db.session.commit()

        util.update_lead_status(row, lead_activity = 'RECEIVED_MESSAGE')

        # If this is a regular reply (not an appointment-action reply), send an SMS notification to the sales person
        # TODO: Also send a notification on appointment-related replies.
        if is_general_reply:
            to_phone = None
            sales_person = None

            # Get the sales person's phone from their SMAI profile
            if last_message and last_message.user_id:
                sales_person = db.session.query(User)\
                    .filter(User.id == last_message.user_id, User.phone != None)\
                    .first()
                if sales_person:
                    to_phone = sales_person.phone

            # If not available, get the sales person's phone from their CRM profile
            # TODO: This needs to be converted to a standard CRM check (not just for VinSolutions)
            if not to_phone:
                sales_person = db.session.query(User) \
                                .join(VinSolutionsUser, VinSolutionsUser.user_id == User.id) \
                                .join(CrmIntegration, CrmIntegration.id == VinSolutionsUser.crm_integration_id) \
                                .join(Leads, Leads.crm_integration_id == CrmIntegration.id) \
                                .filter(Leads.id == row.id, User.phone != None).first()
                if sales_person:
                    to_phone = sales_person.phone

            # If not available, get the company phone number
            if not sales_person:
                lead_company = db.session.query(Company) \
                                    .filter(Company.id == row.company_id, Company.phone != None).first()
                if lead_company:
                    to_phone = lead_company.phone

#             if to_phone:
#                 activity_center_phone, _ = util.get_from_number(db.session, row.company_id, 'ACTIVITY_CENTER')
#                 if not activity_center_phone:
#                     raise Exception(
#                         'Error: Unable to find System User/Phone for the company')

#                 print(f"activity_center_phone (twilio) = {activity_center_phone}, user_phone (user) = {to_phone}")
#                 lead_url = f'{APP_URL}/engagements/activity-center/{to_phone.replace("+", "")}'
#                 send_sms(
#                         from_number=activity_center_phone, to_number=to_phone,
#                         message_body=(
#                             f'''
#                             You have a new message from the lead {row.full_name}:
# "{message_body}"
# Please login to {util.make_shorten('https://app.funnelai.com/')} and engage with the lead from the 'Activity Center'
# {util.make_shorten(lead_url)}.
#                             '''
#                         )
#                     )

        if to_phone:
            if not user:
                campaign = db.session.query(Campaign).filter(Campaign.id == campaign_id).first()
                user_id = last_message.user_id if last_message else (campaign.user_id if campaign else None)
                if user_id:
                    user = db.session.query(User).filter(
                                    User.id == user_id).first()
                if not user:
                    user = db.session.query(User).filter(
                                    User.phone == to_number).first()

            if user:
                lead_message = {
                    "id": message.id,
                    "system_user_id" : message.system_user_id,
                    "lead_id" : message.lead_id,
                    "user_id" : message.user_id,
                    "channel_id" : message.channel_id,
                    "campaign_id" : message.campaign_id,
                    "campaign_template_id" : message.campaign_template_id,
                    "direction" : message.direction.value,
                    "date_sent" : datetime.strftime(message.date_sent, "%Y-%m-%dT%H:%M:%S") if message.date_sent else None,
                    "date_received" : datetime.strftime(message.date_received, "%Y-%m-%dT%H:%M:%S") if message.date_received else None,
                    "content" : message.content,
                    "message_log": {
                        "id": message_log.id,
                        "message_id": message_log.message_id,
                        "to_phone": message_log.to_phone,
                        "from_phone": message_log.from_phone,
                    }
                }
                
                lead_url = f'{APP_URL}/engagements/activity-center/{to_phone.replace("+", "")}'
                notification_message = f"You have received new message from {row.full_name}. {util.make_shorten(lead_url)}"
                socketio_obj.trigger('received_message', {
                                    "lead_id": row.id, "user_id": user.id, 
                                    "lead_message": lead_message,
                                    "message": notification_message
                                })

                fcm_devices = db.session.query(FCMDevice).filter(FCMDevice.user_id == user.id)
                if fcm_devices:
                    fcm_init.send([fcm_device.registration_id for fcm_device in fcm_devices], "New Lead Message", notification_message)

                notification = Notification(user_id=user.id, read=False, date=datetime.utcnow(),
                                                    notification_type='RESPONSE', 
                                                    text=notification_message)
                db.session.add(notification)
                db.session.commit()

                if is_general_reply:
                    trigger_nudge_event.start_scheduler('REMINDER_SP_LEAD_MESSAGE', user, message.lead_id, message.id)

        if campaign_id:
            camp_lead_sum = db.session.query(CampaignLeadSummary).filter(
                CampaignLeadSummary.campaign_id == campaign_id,
                CampaignLeadSummary.lead_id == row.id
            ).first()
            if not camp_lead_sum:
                camp_lead_sum = CampaignLeadSummary(
                    campaign_id=campaign_id, lead_id=row.id, status="RESPONDED", last_message_sent_date=None,
                    last_message_received_date=received_date, num_attempts_before_response=0)
                db.session.add(camp_lead_sum)
                db.session.commit()
                db.session.refresh(camp_lead_sum)
            else:
                camp_lead_sum.last_message_received_date = received_date

                # If reply more than 1 then it's lead as a ENGAGED status.
                reply_messages = db.session.query(func.count(Message.id))\
                    .filter(Message.lead_id == row.id, Message.date_received != None)
                camp_lead_sum.status = 'ENGAGED' if reply_messages[0][0] > 1 else 'RESPONDED'

                db.session.add(camp_lead_sum)
                db.session.commit()


def save_status(message_sid, message_status):
    """Save message status to the database.

    Args:
        message_sid: A string representing the ID of the message (generated by Twilio)
        message_status: A string representing the status of the message.
    """
    message = db.session.query(Message).filter(Message.message_sid == message_sid).one()
    message.message_status = message_status
    db.session.add(message)
    db.session.commit()

    if message_status == 'delivered':
        campaign_lead_summary = db.session.query(CampaignLeadSummary).filter(
                                    CampaignLeadSummary.lead_id == message.lead_id,
                                    CampaignLeadSummary.campaign_id == message.campaign_id).first()
        if campaign_lead_summary and campaign_lead_summary.status.value in ['SENT', 'QUEUED', 'UNCONTACTED']:
            campaign_lead_summary.status = 'DELIVERED'
            db.session.add(campaign_lead_summary)
            db.session.commit()


def generate_ical(appointment_uuid, start_datetime, end_datetime, saleperson_name, saleperson_email, lead_email,
                  location, description, sequence=0, status='CONFIRMED', summary="Appointment at SMAI"):
    s = f'''BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//{SITE_TITLE}// v1.0//EN
CALSCALE:GREGORIAN
METHOD:REQUEST
BEGIN:VEVENT
DTSTART:{start_datetime.strftime('%Y%m%dT%H%M%SZ')}
DTSTAMP:{datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}
DTEND:{end_datetime.strftime('%Y%m%dT%H%M%SZ')}
ORGANIZER;CN={saleperson_name}:mailto:{saleperson_email}
UID:{appointment_uuid}
ATTENDEE;CUTYPE=INDIVIDUAL;ROLE=REQ-PARTICIPANT;PARTSTAT=ACCEPTED;RSVP=FALSE;CN={lead_email};X-NUM-GUESTS=0:mailto:{lead_email}
ATTENDEE;CUTYPE=INDIVIDUAL;ROLE=REQ-PARTICIPANT;PARTSTAT=ACCEPTED;RSVP=FALSE;CN={saleperson_email};X-NUM-GUESTS=0:mailto:{saleperson_email}
DESCRIPTION: {description}
LOCATION:{location}
SEQUENCE:{sequence}
STATUS:{status}
SUMMARY:{summary}
TRANSP:OPAQUE
BEGIN:VALARM
TRIGGER:-PT15M
ACTION:DISPLAY
DESCRIPTION:Reminder
END:VALARM
END:VEVENT
END:VCALENDAR'''
    return s


def look_up_phone_type(phone):
    """Returns the type of the phone number.

    Args:
        phone: A string representing the phone number.

    Returns:
        string: Representing the type of phone number (`landline`, `mobile`, or `voip`).
    """
    try:
        phone_number_type = client.lookups.phone_numbers(phone).fetch(type='carrier').carrier.get('type')
        return phone_number_type
    except TwilioRestException as e:
        if e.code == 20404:
            return "Invalid"
        else:
            print(e)
            return None


def send_mms(from_number, to_number, message_body, image_url):
    """Sends MMS message using Twilio.

    This uses the Twilio Python Helper Library to send SMS to a give phone number. The `from_number` is typically a
    number bought from Twilio.

    The status callback passed Twilio is important as that is where the webhook call will be sent about the status of
    message (sent, delivered, etc.)

    Args:
        from_number: A string representing the phone number to send the message from.
        to_number: A string representing the phone number to send the message to.
        message_body: A string representing the message to be sent.
        image_url: A string representing url of the image you want to send with the SMS.

    Returns:
        string: A string representing the ID of the message generated by Twilio.
    """
    try:
        message = client.messages \
                        .create(
                            body=message_body,
                            # Instead of from_ we create a messaging service with a pool of numbers
                            # and send using the message service.
                            # messaging_service_sid='MG9752274e9e519418a7406176694466fa',
                            from_=from_number,
                            status_callback=f'{CALLBACK_URL}/message-status',
                            to=to_number,
                            media_url=[image_url,],
                        )
        return message.sid
    except TwilioRestException as e:
        print(e)
        return None
